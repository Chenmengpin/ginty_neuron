---
title: "Ginty lab Neuron RNA-Seq Analysis"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_depth: 4
    fig_caption: true
    fig_width: 8
    fig_height: 6
author: "Meeta Mistry"
date: "04/29/2014"
---

```{r setup, echo=FALSE}
 
# Setup report details
clientname="Yang Zheng"
clientemail="zylittlep@gmail.com"
lablocation="Neurobiology"
analystname="Meeta Mistry"
analystemail="mmistry@hsph.harvard.edu"
```

RNA-Seq analysis for `r clientname` (`r clientemail`) at `r lablocation`. Contact `r analystname` (`r analystemail`) for additional details. Request from client was:     

> We've collected some RNA deep-sequencing data and we'd really appreciate your help with our analysis. Our situation is I've finished the sequencing and primary data analysis part via GALAXY. What I need is further bioinformatic analysis, say,distribution, correlation analysis, clustering, generating heat map, etc..... 

## Workflow:   
  * run fastq files through [bcbio](https://bcbio-nextgen.readthedocs.org/en/latest/index.html)
  * [assess QC](https://dl.dropboxusercontent.com/u/35207958/ginty_neuron/qc-summary.html) 
  * Correlation structure / clustering (inter, intra)
  * All vs all comparison
  * Looking for condition-specific genes

## Setup

### Bioconductor and R libraries used

```{r libraries, echo=TRUE}
loadlibs <- function(){
library(ggplot2)
library(reshape)
library(gplots)
library(edgeR)
library(CHBUtils)
library(grid)
library(gridExtra)
library(Biobase)
library(genefilter)
library(RColorBrewer)
library(NMF)
library(DESeq2)
library(SpeCond)
library(ggdendro)
library(vsn)
library(splitstackshape)
}
suppressPackageStartupMessages(loadlibs())
```

### Get variables
- get base directory for analyses
- specify data and results directories
- specify column headers used in metadata file

```{r directories, echo=TRUE}
baseDir=getwd()
dataDir=paste(baseDir, "/data", sep="")
resultsDir=paste(baseDir, "/results", sep="")
metaDir=paste(dataDir, "/meta", sep="")

heatcolors.1 <- rev(brewer.pal(6, "YlOrRd"))
heatcolors.2 <- colorRampPalette(brewer.pal(9, "GnBu"))(100)
cbPalette <- cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", 
                            "#D55E00", "#CC79A7", "#000000")
```

## Load data
Count data is loaded in along with the metadata for each sample. Here we will remove the outlier sample Npy2r3 which displayed an obvious batch effect. We will create an eset object for downstream analysis, and further create a subset of genes that are filtered by variance keeping only genes that show high variability across samples.

```{r load data}
# Load data
counts <- read.delim(file.path(dataDir, 'combined.counts'), sep="\t", row.names=1, header=T)
ann.counts <- read.delim(file.path(dataDir, 'annotated_combined.counts'), sep="\t", row.names=1, header=T)
meta <- read.delim(file.path(metaDir, 'ginty_neuron.tsv'), sep="\t", row.names=1, header=T)
meta <- meta[colnames(counts),]

# Remove outlier sample
outlier <- "Npy2r3"
meta <- meta[which(row.names(meta) != outlier),]
counts <- counts[,which(colnames(counts) %in% rownames(meta))]

# Create eset
eset <- new("ExpressionSet", exprs=as.matrix(counts))
pData(eset) <- meta
fData(eset) <- data.frame(GeneSymbol=ann.counts[,'symbol'], row.names=row.names(ann.counts))

# Filtered by variance eset
var.eset <- varFilter(eset, var.cutoff=0.90)
```

## Clustering of Data

### Sample-to-sample correlation matrix
This heatmap is generated by taking correlation of counts for all pairwise combinations of samples. The samples show high correlations with each other (values higher than 0.93) indicating no major outliers. The two samples TrkC1 and TrkC4_2k that had low mapping rates as pointed out in QC are slightly less correlated, but still in the high range.  

```{r cluster-ica, fig.align='center'}
# Heatmap of sample-to-sample correlation matrix
heatmap.2(cor(counts), trace="none", col=heatcolors.1)
```

### Dendrogram based on euclidian distance of individual samples
This clustering remains the same whether we use the full dataset or the filtered dataset.
```{r cluster-dendro, echo=FALSE, warning=FALSE, fig.width=20}
# High variance genes dendrogram
  meta.x <- pData(var.eset)
  myDist <- dist(t(exprs(var.eset)))
  myTree <-hclust(myDist)
  dhc <- as.dendrogram(myTree)
  ddata <- dendro_data(dhc, type="rectangle")
  ddata$labels <- merge(ddata$labels, meta.x, by.x="label", by.y="row.names")
  ggplot(segment(ddata)) +
    geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
    theme_dendro() +
    geom_text(data=label(ddata), aes(x=x, y=y, label=label, color= label(ddata)[['neurontype']], 
                                     hjust=-0.1), size=6) +
    coord_flip() + scale_y_reverse(expand=c(0.2, 50)) +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          legend.title=element_blank())

```

### PCA of samples based on most variable genes
The PCA doesn't display any specific clustering of the neurontypes, but does highlight the same two outliers as we have seen before, TrkC1 and TrkC4_2k (the two grey outlier dots).
```{r pca, warning=FALSE, fig.align='center', fig.height=12, fig.width=12}
# High variance genes PCA
PCAplot.eset(var.eset, categories='neurontype', title="", colorpalette = cbPalette)
```

## DESeq2: Neuron versus All comparison
First get the data into DESeq object and transform counts for ease in downstream visualization. As demonstrated by the plots below, the regularized log is the preferred method for transformation (the standard deviation is roughly constant along the whole dynamic range).

```{r deseq2-setup, fig.width=20}

# Create DESeq2 dataset
dds <- DESeqDataSetFromMatrix(countData = counts, colData = meta, design = ~ neurontype)
dds <- DESeq(dds)

# Matrix of pseudocounts for downstream visualization: two methods
rld <- rlog(dds)
vsd <- varianceStabilizingTransformation(dds)

# Effects of transformation on variance
par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds))>0)
meanSdPlot(log2(counts(dds,normalized=TRUE)[notAllZero,] + 1), ylim = c(0,2.5), main="Raw counts")
meanSdPlot(assay(rld[notAllZero,]), ylim = c(0,2.5), main="Regularized log")
meanSdPlot(assay(vsd[notAllZero,]), ylim = c(0,2.5), main="VST")
```

### Analysis
We set up the contrasts to assses gene expression changes for each neurontype against all other neurontypes. Significant genes are identfied as log2 FC > 2 and corrected p-value < 0.05. An example heatmap is plotted to show the genes identified for the Peptidergic Nociceptor; the large majority of which are up-regulated with respect to everything else.

```{r deseq2-analysis, fig.align='center'}

# Create list object for teh results 
resultsAll <- vector("list", 7)

# Extract data of specified contrasts; each neuron against everything else
# Start at 2 because the first element is the intercept
for (n in 2:length(resultsNames(dds))){
  contrast <- rep(0, length(resultsNames(dds)))
  contrast[n] <- 1
  res <- results(dds, contrast=contrast) # get results for neuron against all samples
  resultsAll[n-1] <- list(res)
}
names(resultsAll) <- resultsNames(dds)[-1]

# Get significant genes from each comparison
p.cutoff <- 0.05
fc <- 2
sigmat <- sapply(resultsAll, function(x){
            gene.FDR <- as.logical(abs(x$log2FoldChange) > fc & x$padj < p.cutoff)
            return(gene.FDR)}, USE.NAMES=F)
row.names(sigmat) <- row.names(exprs(eset))

# Plot example heatmap 
select <- row.names(sigmat)[which(sigmat[,'neurontypePeptidergic.Nociceptor'])]
heatmap.2(assay(rld)[select,],scale="row", col=heatcolors.2, labRow="", Colv=FALSE, 
          trace="none", dendrogram="row")

```

### Significant genes
The number of genes in each list vary and there is definitely overlap between the lists. 
```{r deseq2-sigtable, results='asis', echo=FALSE, fig.align='center'}
sigout <- cbind(colnames(sigmat), unname(apply(sigmat, 2, function(x){length(which(x))})))
colnames(sigout) <-c("Neurontype", "Number of Significant genes")
kable(sigout, format="markdown", row.names=F)
```

### LTMR gene overlap
We can also look at overlaps within specific/expected groups of interest. For example, a Venn diagram is provided to illustrate the overlap between the three LTMR groups.
```{r imageVenn , fig.align='center', echo=FALSE, fig.align='center', message=FALSE}
require(png)
img1 <- readPNG("~/R/ginty_neuron/DESeq2_results/LTMR_venn.png")
grid.raster(img1)
```

## SpeCond: Identifying condition specific genes
We used [SpeCond](http://genomebiology.com/content/12/10/R101), an R package to to detect condition-specific genes which are essentially outliers in an expression pattern. In order to detect these *outliers*, SpeCond fits a mixture of normal distributions to the expression values. N.B. This method is best used when studying 8 conditions or more.

1. examine the distribution of expresssion values and fit 1-3 normal distributions to the data (mclust)
2.  define the null distribution for a gene across conditions using a normal mixture model as well as candidate outlier observtions (three criterion are evaluated)
3.  compute p-values of the expression values using the null distribution (the sum of the P-values obtained from each mixture component)
4. repeat 1-4 for every single gene and adjust p-values for multiple comparisons
5. identify significant condition-specific expression values of the gene

```{r specond, warning=FALSE, eval=FALSE}

generalResult <- SpeCond(eset, param.detection=NULL, multitest.correction.method="BH", 
                         condition.factor=var.eset$neurontype, condition.method='mean', prefix.file="Ginty", 
                         print.hist.pv=FALSE, fit1=NULL, fit2=NULL, specificOutlierStep1=NULL)

specificResult=generalResult$specificResult

getFullHtmlSpeCondResult(SpeCondResult=generalResult, param.detection=specificResult$param.detection, 
                         page.name="NeuronSpeCond_results", page.title="Neuron specific results", 
                         sort.condition="all", heatmap.profile=TRUE, heatmap.expression=TRUE, 
                         heatmap.unique.profile=TRUE, expressionMatrix=exprs(var.eset))
```

The program generates an HTML report along with text and figure output. For the full dataset, the link to the HTML file can be found [here](./GintyFull_NeuronSpeCond_results.html) and for the filtered dataset the link is [here](./Ginty_NeuronSpeCond_results.html). For consistency in comparison with DESeq2 we will focus on results using the full dataset. Only seven of the specific genes exclusively belong to one neurontype; majority of genes are specific to two neurontypes. The profile heatmap from the report (also plotted below), represents the gene specificity (y axis) over the conditions (x axis), the colors correspond to down (red), up (blue) and non-specific (white).

```{r imageSpecond , fig.align='center', echo=FALSE, fig.align='center', message=FALSE}
img2 <- readPNG("~/R/ginty_neuron/GintyFull_General_Result/GintyFull_profile_heatmap.png")
grid.raster(img2)
```

### Specific genes
Of the total dataset, 1060 genes are identified as being specific and only seven of which are exclusive to one neurontype. We can read in the results table and extract out specifc gene lists. From the set of genes, four of these genes are Peptidergic nociceptor genes (BC039771, Trp63, Pdcd4), three are Aβ-RA-LTMR (Gm24339, Ube2i, Nxf1) and one gene for Aβ-Nociceptor (Dtd2). The stripcharts below indicate that these genes don't seem particularly specific.

```{r specond-results, echo=FALSE}

df <- read.delim('GintyFull_General_Result/GintyFull_result_specific_probeset.txt', header=T, sep="\t", as.is=T)

wide.df <- concat.split.multiple(df, split.cols = c("Condition.up", "Condition.down"), seps = ",", direction = "wide")
long.df <- Reshape(wide.df, id.vars = c("Gene"), var.stubs = c("Condition.up", "Condition.down"), sep = "_")

up <- aggregate(Gene~Condition.up, c, data=long.df)
up <- up[-1,]
down <- aggregate(Gene~Condition.down, c, data=long.df)
down <- down[-1,]

all <- merge(up, down, by.x="Condition.up", by.y="Condition.down")
neurontypes <- vector("list", 7)
names(neurontypes) <- levels(meta$neurontype)

for (n in levels(meta$neurontype)){
   row <- which(all[,1] == n)
   genes <- c(unname(unlist(all$Gene.x[row])), unname(unlist(all$Gene.y[row])))
   neurontypes[n] <- list(genes)
 }
```

```{r, specGenes, echo=FALSE, fig.align='center', fig.height=20, fig.width=20, warning=FALSE}
# Get exclusive genes
specific <- c(which(df$X..condition.up == 1) , which(df$X..condition.down == 1))
df.specific <- df$Gene[specific]
exprs(eset) <- assay(rld)
color <- brewer.pal(n=7, name="Set3")


# stripchart
# Set up a blank stripchart
par(las=2, mfrow=c(4,2), mar=c(2,4,2,2), cex=1.5)

for (i in df.specific){
  	stripchart(
			exprs(eset)[i,] ~ eset$neurontype,
			method="jitter", vertical=TRUE,
			ylab="log2 (expression)", col=NA,
			xlim=c(0.25,nlevels(eset$neurontype)+0.75),
			ylim=range(exprs(eset)[i,]),
			main=fData(eset)[i,],
      xaxt="n"
		);
		# Then draw points for each sample
		for (n in 1:nlevels(eset$neurontype)) {
			j <- which(eset$neurontype == levels(eset$neurontype)[n]);
			stripchart(
				exprs(eset)[i, j],
				method="jitter", vertical=TRUE, add=TRUE, at=n,
				pch=21, cex=1.5, bg=color[n]
			);
		}
}
plot.new()
legend("topleft", inset=0, title="Neurontype", legend=levels(pData(eset)$neurontype), fill=color, horiz=FALSE, cex=1.2)

```

## Comparison of results between methods
The two methods generate a gene list for each of the neurontypes, with DESeq producing a much larger number of genes. In the table below we report the number of genes identifed by each method and the intersection between the two methods. The intersection might be a good gene list to start with. 

```{r comparison, results='asis'}
sigout <- cbind(colnames(sigmat), unname(apply(sigmat, 2, function(x){length(which(x))})))
sigout.specond <- do.call(rbind, lapply(neurontypes, function(x) length(x)))

overlaps <- numeric()
for (n in 1:nrow(sigout)){  
  geneset.1 <- row.names(sigmat)[which(sigmat[,n])]
  geneset.2 <- neurontypes[[n]]
  overlaps <- c(overlaps, length(which(geneset.1 %in% geneset.2)))
}

overlaps <- cbind(as.data.frame(sigout.specond), sigout[,2], overlaps)
names(overlaps) <- c("SpeCond", "DESeq2", "Overlap")
kable(overlaps, format="markdown")

```


## NMF: Non-negative Matrix Factorization
Similar to PCA or ICA, the goal of NMF is to explain the observed data using a limited number of basis components, which when combined together approximate the original data as accurately as possible. The basis components can be interpreted as metagenes that capture gene expression patterns specific to different groups of samples. 

### Estimating the factorization rank
From ["An introduction to NMF package"]("http://nmf.r-forge.r-project.org/vignettes/NMF-vignette.pdf")  

> A critical parameter in NMF is the factorization rank r. It determines the number of metagenes used
to approximate the target matrix. A common way of deciding on r is to try different values, compute some quality measure of the results, and choose the best value according to this quality criteria.    


The protocol for estimating the factorization rank is as follows:   
1. Evaluate quality measures for a range of rank values   
2. Assess overfitting    
3. Choose appropriate rank and evaluate different algorithms     
4. Choose appropriate algorithm and repeat steps 1-2     
5. Run with final parameters and increase iterations for algorithm to fully converge and yield as accurate a result as possible


The results of the initial steps (1-3) are not shown here, rather we show the final steps from which we chose parameter values. Because it is quite memory intensive the following [R scripts](./scripts/scripts.tar.gz) were used and run on a cluster environment.  

### Algorithm comparison
Using default values and the filtered datset we evaluated four of the most popular algorithms and compare graphs of the residual approximation error. The objective value of error is tracked along the iterative optimization process (50 runs). In these plots, we look for algorithms that converge at lower objective values (achieving the most decrease in residuals), but also at the convergence speed (number of iterations it takes). Based on these results we chose Lee as the optimal algorithm.

```{r comparealgs, fig.align='center', echo=FALSE, fig.align='center', message=FALSE}
img4 <- readPNG("~/R/ginty_neuron/NMF_results/nmf.algcompare.png")
grid.raster(img4)
```

### Quality measures of rank factorization
We evaluated rank values between 4 and 8, performing 50 runs on each rank value to get a robust estimate of outcome.  The sharp decrease in the cophenetic correlation coefficient at rank r = 6 indicates that substantially less stability is achieved using more than six clusters. The largest inflection points of the rss curve occurs at the r = 5. 

```{r estimatefactoriziationrank, fig.align='center', echo=FALSE, fig.align='center', message=FALSE}
img5 <- readPNG("~/R/ginty_neuron/NMF_results/nmf.lee.png")
grid.raster(img5)
```

### Assess overfitting
Even for random data, increasing factorization ranks lead to more variables to fit the data, possibly leading to overfitting the data. To assess this, we can run the same metrics after randomly permuting the data, and comparing the performance of the original and randomized datasets. Dotted lines represent results from randomized data. 

```{r overfitcheck, fig.align='center', echo=FALSE, fig.align='center', message=FALSE}
img6 <- readPNG("~/R/ginty_neuron/NMF_results/nmf.overfitting_lee.png")
grid.raster(img6)
```

### Final run (r=6; algorithm='lee')
Using the final parameters, we let the algorithm run with 1000 iterations. From the best fit, a heatmap of the consensus matrix is plotted to see if the consensus blocks obtained correspond to the known cell types. The consensus matrix can be thought of as average connectivity matrix over multiple runs. From a statistical point of view, this gives the empirical probability for each sample pair to be clustered together.

```{r consensusmap, fig.align='center', echo=FALSE, fig.align='center', message=FALSE, fig.keep='high'}
img7 <- readPNG("~/R/ginty_neuron/NMF_results/consensus_final.png")
grid.raster(img7)
```

Based on our results, it appears that six metagenes can be used to divide the samples and best allow us to separately classify the different neuron types. The consensus map shows that we can most accurately classify three neuron groups C-LTMR, Peptidergic and Nonpeptidergic (they align well with three basis vectors) but samples for the remaining groups are scattered. 

### Neuron-specific genes
We can extract the features (genes) with the most specifciity for each of the metagenes and assign them to the corresponding neurontype based on the consensus map above.

```{r neurongenes, results='asis', echo=FALSE}

# Read in files
nmf.files <- vector("list", 6)
for (i in 1:6){
  x <- read.delim(paste("NMF_results/Rank6.metagenes.", i, ".txt", sep=""), header=T, sep="\t", row.names=1)
  nmf.files[[i]] <- x
}

sigout.nmf <- do.call(rbind, lapply(nmf.files, function(x) nrow(x)))
row.names(sigout.nmf) <- paste("Metagene", 1:6, sep="")
ntypes <- c(rep("NA", 2), "C-LTMR/A-LTMR",  "Nopeptidergic", "NA", "Peptidergic")
sigout.nmf <- cbind(sigout.nmf, ntypes)
colnames(sigout.nmf) <- c("Number of Features/Genes", "Neurontype")
kable(sigout.nmf, format="markdown")

```



